"""
Analyse experte des colonnes Ã  supprimer
Expert Data Science - Identification automatique des colonnes inutiles
"""

import pandas as pd
import numpy as np

print("=" * 100)
print("ANALYSE EXPERTE DES COLONNES Ã€ SUPPRIMER")
print("=" * 100)

# Charger le dataset original
df = pd.read_csv('ptbxl_database.csv', index_col='ecg_id')

print(f"\nðŸ“Š Dataset original: {len(df):,} enregistrements Ã— {len(df.columns)} colonnes")

# Calculer les statistiques pour chaque colonne
missing_pct = (df.isnull().sum() / len(df) * 100).sort_values(ascending=False)

print("\n" + "=" * 100)
print("1. COLONNES AVEC VALEURS MANQUANTES (>0%)")
print("=" * 100)

for col, pct in missing_pct[missing_pct > 0].items():
    status = "ðŸ”´ SUPPRIMER (>95%)" if pct > 95 else "âš ï¸  IMPUTER (50-95%)" if pct > 50 else "âœ“ GÃ‰RABLE (<50%)"
    print(f"{col:40s} : {pct:6.2f}% manquant  {status}")

# RÃˆGLES D'EXPERT POUR SUPPRESSION
print("\n" + "=" * 100)
print("2. DÃ‰CISIONS EXPERTES DE SUPPRESSION")
print("=" * 100)

to_drop = []

# RÃˆGLE 1: Colonnes avec >95% de valeurs manquantes (inutilisables)
high_missing = missing_pct[missing_pct > 95].index.tolist()
if high_missing:
    print(f"\nâœ“ RÃˆGLE 1: Colonnes >95% vides ({len(high_missing)}) - AUCUNE VALEUR INFORMATIVE")
    for col in high_missing:
        print(f"    â€¢ {col:40s} ({missing_pct[col]:.2f}% vide)")
        to_drop.append(col)

# RÃˆGLE 2: Colonnes textuelles de rapport (non structurÃ©es)
text_cols = ['report', 'initial_autogenerated_report']
print(f"\nâœ“ RÃˆGLE 2: Colonnes texte rapport ({len(text_cols)}) - NON STRUCTURÃ‰, NLP NÃ‰CESSAIRE")
for col in text_cols:
    if col in df.columns:
        print(f"    â€¢ {col:40s} (texte libre, nÃ©cessite NLP)")
        to_drop.append(col)

# RÃˆGLE 3: Colonnes redondantes (dÃ©jÃ  encodÃ©es/extraites)
redundant = ['scp_codes', 'age_group', 'bmi_category', 'recording_date']
print(f"\nâœ“ RÃˆGLE 3: Colonnes redondantes ({len(redundant)}) - DÃ‰JÃ€ ENCODÃ‰ES AILLEURS")
for col in redundant:
    if col in df.columns:
        print(f"    â€¢ {col:40s} (information dÃ©jÃ  capturÃ©e)")
        to_drop.append(col)

# RÃˆGLE 4: MÃ©tadonnÃ©es de validation trÃ¨s incomplÃ¨tes
validation_cols = ['second_opinion', 'validated_by']
print(f"\nâœ“ RÃˆGLE 4: MÃ©tadonnÃ©es validation incomplÃ¨tes ({len(validation_cols)}) - >70% MANQUANT")
for col in validation_cols:
    if col in df.columns and missing_pct[col] > 70:
        print(f"    â€¢ {col:40s} ({missing_pct[col]:.2f}% vide)")
        to_drop.append(col)

# DÃ©dupliquer
to_drop = list(set(to_drop))

print("\n" + "=" * 100)
print(f"3. LISTE FINALE DE SUPPRESSION ({len(to_drop)} COLONNES)")
print("=" * 100)
for col in sorted(to_drop):
    if col in df.columns:
        pct = missing_pct.get(col, 0)
        print(f"  â€¢ {col:40s} ({pct:6.2f}% vide)")

# Sauvegarder la liste
with open('colonnes_a_supprimer.txt', 'w', encoding='utf-8') as f:
    f.write("# Colonnes Ã  supprimer - DÃ©cision experte\n")
    f.write(f"# Total: {len(to_drop)} colonnes\n\n")
    for col in sorted(to_drop):
        if col in df.columns:
            f.write(f"{col}\n")

print(f"\nâœ“ Liste sauvegardÃ©e dans: colonnes_a_supprimer.txt")

# Afficher le code Python pour le preprocessing
print("\n" + "=" * 100)
print("4. CODE PYTHON POUR PREPROCESSING")
print("=" * 100)
print("\ncolumns_to_drop = [")
for col in sorted(to_drop):
    if col in df.columns:
        print(f"    '{col}',")
print("]")

print("\n" + "=" * 100)
print(f"âœ“ ANALYSE TERMINÃ‰E - {len(to_drop)} colonnes identifiÃ©es pour suppression")
print("=" * 100)
